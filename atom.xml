<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[読書帳]]></title>
  <link href="http://delta2323.github.io/atom.xml" rel="self"/>
  <link href="http://delta2323.github.io/"/>
  <updated>2014-10-09T00:27:32+09:00</updated>
  <id>http://delta2323.github.io/</id>
  <author>
    <name><![CDATA[Kenta OONO]]></name>
    <email><![CDATA[k.oono.delta@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PFIセミナーで実験プログラム開発方法論について話しました]]></title>
    <link href="http://delta2323.github.io/blog/2014/10/09/experiment-oriented-program/"/>
    <updated>2014-10-09T00:06:00+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/10/09/experiment-oriented-program</id>
    <content type="html"><![CDATA[<p>先日9月25日の社内セミナーにて「実験プログラム開発方法論」というタイトルで発表を行いました。
発表資料はSlideShareで公開しています。当日の発表はUstreamのPFIチャンネルから視聴可能です。
また、発表に関連する資料群（デモのレポジトリ・実験メモ・発表に関連して書いた文書）などをgoogle docsで公開しています。</p>

<ul>
  <li><a href="http://www.ustream.tv/channel/pfi-show">PFI Show(Ustream)</a></li>
  <li><a href="https://docs.google.com/document/d/1PB6qHAt2Lyvm_AUXjiAjOt1v9BgbATnKtb38buwlOZI">20140925PFIセミナー関連資料置き場</a></li>
</ul>

<iframe src="http://www.slideshare.net/slideshow/embed_code/39497239 " width="595" height="446" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen=""></iframe>

<p>以下では発表内容の簡単なまとめ、発表の補足、実験プログラムについて考える経緯について、随筆的に書いていこうと思います。</p>

<!-- more -->

<h2 id="section">発表内容について</h2>

<p>実験プログラムは造語で、（科学）実験を行うために開発するソフトウェアを意図しています。
発表では、実験プログラムが持つ特徴・典型パターン・開発上の課題とその解決策（案）について話しました。
一部まとめの繰り返しになりますが、今回の発表での要旨・主張は以下の通りです。</p>

<ul>
  <li>
    <p>実験プログラム開発にはソフトウェアの開発の方法論が有効。ただし、実験プログラムの開発に適した形で適用する事が必要。</p>
  </li>
  <li>
    <p>実験プログラムはそれ単体として存在するのではなく、それらへの入力（データセット・設定ファイル）・出力（実験結果・ログ）・実験手順（実験手順プログラム・ドキュメント）・環境など周辺に存在するモジュールにも依存しており、実験プログラムと同様に管理・開発が必要である。</p>
  </li>
  <li>
    <p>実験プログラムでは実験結果を出すことの優先度が高い点が通常のソフトウェアの開発と異なり、ソフトウェアの品質にかけるコスト（リファクタリング・バージョン管理・関数の汎用性）との優先度の問題がしばしば発生する。</p>
  </li>
  <li>
    <p>実験結果の再現性を保ち、結果を後になって有効活用するには、生成方法と生成結果はそれらを独立して管理するだけではなく、それらの対応付けを併せて管理する事が重要。</p>
  </li>
</ul>

<h2 id="section-1">発表の補足</h2>

<ul>
  <li>
    <p>発表中で「パイプラインは実験プログラム固有」という旨の内容を話したのですが、通常のソフトウェア開発でも前のビルド結果を別のプログラムのビルドに利用するということは当たり前のように行いますので、あまり実験プログラムに固有というのは適切ではなかったです。</p>
  </li>
  <li>
    <p>この発表を考えた当初はもう少し細かなノウハウについてお話をすることを想定していましたが、いざ資料にまとめてみると、そこに至るまでの前提・導入の話が予想以上にあることがわかり、結果的にそれらについてはほとんど触れられませんでした。それらについては、以下の文書も参考にして下さい（前述の資料置き場にもリンクはあります）。</p>

    <ul>
      <li><a href="https://docs.google.com/document/d/11Y3NYVCHilCRT-xyGEYuy8EphOyouc_iWOqO_ZiDLX0">git, mafを用いた実験プログラム開発方法論</a></li>
    </ul>
  </li>
  <li>
    <p>今回は実験結果を得ることを目的としたプログラムが興味対象で、そのプログラムを第三者が利用する事はあまり想定していませんでした。しかしそ、libsvm/liblinearやmecabなどのツールによって関連する分野の発展が加速された事を考えると、ソフトウェアとして第三者に利用されることを想定した実験プログラムを今回の話から除いてしまったのは話半分と言わざるを得ないと思います。これらについてはまた別の問題として気になる話ではあります。</p>
  </li>
</ul>

<h2 id="section-2">発表のきっかけ</h2>

<p>（書いていたら思ったより長文になってしまいました）</p>

<p>今回このような発表を行ったきっかけは、自分がこういう方法論を欲していたというのがあります。
仕事やプライベートで論文を読んだり、アルゴリズムを試しに書く事が多いのですが、アルゴリズムそのものの他に効果的なアルゴリズムを開発する方法も自然と問題意識として持っていました。</p>

<p>周りの紹介でソフトウェア開発という分野を知り、関連する書籍やブログなどを読んでみると、コードを書いている時に感じる疑問にまさに答えてくれるようなものが多数でした。例えば、自分がこの会社に来て最初に読んだ本の一つがClean Codeという品質の高いコードを書くための技術についての本です。
我流でコードを書いていた時に比べると効率や品質は大分意識できるようになりました（本当にきちんと書けているかどうかは周りに聞いてみないとわからないですが…）。</p>

<p>一方で、これらの手法のうち幾つかは自分のケースにうまく適用できないと感じる事もありました。
もちろん自分が手法を十分マスターしていない事も理由の一つだと思いますが、
少し身の程をわきまえずに大胆な仮説を立てて、自分が開発しているプログラムは一般のソフトウェアとは要求が異なる部分もあるのではないかと考えてみることにしました。</p>

<p>改めて思い返してみると、公開された場にある実験プログラム開発のノウハウというのはそれほど多くはないように思います。
今回自分が紹介したようなジレンマは実験プログラムを開発していれば自然と発生する問題のはずなので、機械学習を研究するグループがこのようなノウハウを持っていないとは考えづらいです。
おそらく各研究グループの中でこのようなノウハウは秘伝のタレとして伝えられたり、仲間同士で情報交換されており、外部になかなか現れていないだけだと思います。</p>

<p>また、実験プログラム開発上の課題を課題に思うのは、研究開発という一部の職種の中で、さらにプログラム開発が研究に伴う一部の方々だけであるはずなので、ニーズがなかったとしても不思議ではありません。
実際前述の「git, mafを用いた実験プログラム開発方法」の文書も、もともとはノウハウを社内の他のメンバーに共有しようという動機で書き始めました。</p>

<p>もちろん公開の場でのノウハウの共有が全くないとは言えません。例えば機械学習系のライブラリのレポジトリのログで開発の過程を追ったり、githubのissueやgoogle groupではそのようなノウハウが議論される事がしばしばあります。しかし、埋もれていて見えていないノウハウの蓄積というのはもっとあるはずだと推測しています。</p>

<p>ノウハウを方法論として確立する事はメリットは大きいと考えています（少なくとも実験プログラムを書く人間、というか自分はほしいです）。
例えば以下の様な効果を期待しています</p>

<ul>
  <li>異なる研究グループの間で共通言語ができ、ノウハウのスムーズな共有・交換につながる</li>
  <li>開発ノウハウを身につけることで、その部分で悩むことが少なくなれば、開発内容そのものにリソースを集中する事ができる</li>
  <li>方法論としてまとめる事で何も意識せずに開発をしていたら3年かかるようなノウハウの修得が半年でできれば、残った時間をアルゴリズムの研究に費すことができる</li>
</ul>

<p>方法論を確立することの重要性を強調したいという意図があり、今回の発表では「実験プログラム”方法論”」などという大それたタイトルを付けました。</p>

<p>今回残念だったのは、あまりサーベイや知り合いへのインタビューができず、世の中でのこのような実験プログラムの開発の現状をあまり把握できなかったということです。
おそらく世の中は自分が話した内容よりももっと進んでいて、「こんなの知ってる」と言う感想を持っている方も多くいるのではないかと思います。
自分の所ではこうしている、もっとここはこう工夫できるのではないかなどの感想がありましたら是非いただければと思います。
今回の発表が実験プログラム開発の議論のきっかけになれば幸いです。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Matplotlib_on_macos]]></title>
    <link href="http://delta2323.github.io/blog/2014/10/07/matplotlib-on-macos/"/>
    <updated>2014-10-07T19:17:01+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/10/07/matplotlib-on-macos</id>
    <content type="html"><![CDATA[<p>http://qiita.com/katryo/items/918667f28301fdec89ba
http://matplotlib.org/users/customizing.html</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tokenizer_builder_pattern]]></title>
    <link href="http://delta2323.github.io/blog/2014/10/03/parser-tokenizer-pattern/"/>
    <updated>2014-10-03T05:58:08+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/10/03/parser-tokenizer-pattern</id>
    <content type="html"><![CDATA[<p>mafで最近よく使うお気に入りパターン。</p>

<p>データのフォーマットを変換するときに、処理の最初にデータをパーズし、処理の最後にデータを後段の処理モジュールが受け入れられるフォーマットで出力する必要がある。</p>

<p>このパターンはデータをパーズする具体的方法を記述する部分と具体的にデータファイル全体をパーズする
具体例として、vowpal形式のファイルを入力し、何らかの処理をした上で、libsvm形式で出力する場合を考える。
それぞれの形式は以下を参照</p>

<p>vowpal
https://github.com/JohnLangford/vowpal_wabbit/wiki/Input-format
libsvm
https://github.com/cjlin1/libsvm/blob/master/README</p>

<p>どちらも1行に1サンプルの情報が記述されている
まず、1行の文字列を得て、パーズを行う関数を用意する</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def vowpal_tokenizer(line):
</span><span class="line">    
</span><span class="line">    pass</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>そして、mafのタスクにparserを渡す</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">exp(source = 'path/to/input/file',
</span><span class="line">    target = 'maf/output/node',
</span><span class="line">	rule = parse_each_line(tokenizer = util.parser.vowpal_tokenizer)
</span><span class="line">	)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>ruleの中でtokenizerに1行ずつ順にデータを渡していく</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@maflib.util.rule
</span><span class="line">def parse_each_line(task):
</span><span class="line">    tokenizer = task.paramter['tokenizer']
</span><span class="line">	samples = []
</span><span class="line">    with open(task.inputs[0].read()) as i:
</span><span class="line">	     for line in i.readlines():
</span><span class="line">		     sample = tokenizer(line)
</span><span class="line">			 samples.append(samples)
</span><span class="line">    task.outputs[0].write(json.dumps(samples))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>出力についても同様に、builderを関数として用意して、ruleに渡す</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def libsvm_builder(label, values):
</span><span class="line">    pass</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">exp(source = 'maf/input/node',
</span><span class="line">    target = 'maf/output/node',
</span><span class="line">	rule = builder_each_line(builder = util.builder.libsvm_builder)
</span><span class="line">)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>builderの具体的な処理の中身は次の通り</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@maflib.util.rule
</span><span class="line">def builder_each_line(task):
</span><span class="line">    builder = task.paramter['builder']
</span><span class="line">    j = json.loads(task.inputs[0].read())
</span><span class="line">	for sample in j
</span><span class="line">	    line = builder(sample['label'], sample['feature'])
</span><span class="line">		task.outputs[0].write(line, 'a')</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>データ形式の変換はtokenizerとbuilderを組み合わせれば良い</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">exp(source = 'path/to/input/file',
</span><span class="line">    target = 'path/to/output/file',
</span><span class="line">	rule = convert_each_line(tokenizer = util.tokenizer.vowpal_tokenizer,
</span><span class="line">	                         builder = util.builder.libsvm_builder
</span><span class="line">	)
</span><span class="line">)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>convert関数には具体的なtokenizer, builderの手続きは書かず、ロジックだけを書く</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@maflib.util.rule
</span><span class="line">def convert_each_line(task):
</span><span class="line">    tokenizer = task.parameter['tokenizer']
</span><span class="line">    builder = task.paramter['builder']
</span><span class="line">	with open(task.inputs[0], 'r') as i, open(task.outputs[0], 'w') as o:
</span><span class="line">	    for line in i.readlines():
</span><span class="line">		    o.write(builder(tokenizer(line)))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>データのフォーマットはいろいろなバラエティがある一方、入力データの処理の仕方はフォーマットによらず共通している（例えば1行に1サンプルなど）場合が多く、
このパターンでは、パーズの具体的な手続きとファイル全体の処理方法を分離することでそれをプラガブルにしている。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Suwa_todo_mcmc]]></title>
    <link href="http://delta2323.github.io/blog/2014/09/23/suwa-todo-mcmc/"/>
    <updated>2014-09-23T18:23:28+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/09/23/suwa-todo-mcmc</id>
    <content type="html"><![CDATA[<p>http://arxiv.org/pdf/1106.3562v2.pdf
http://www-adsys.sys.i.kyoto-u.ac.jp/mohzeki/YSMSPIP/Abst2012/abst_suwa.pdf</p>

<p>http://www-adsys.sys.i.kyoto-u.ac.jp/mohzeki/YSMSPIP/Proc2012/all.pdf</p>

<p>適当な確率分布π(x)をMCMCでサンプリングする場合、πT = πとなるような遷移行列Tを取ってきて、</p>

<ul>
  <li>
    <p>適当な初期状態x_{0}をとる</p>
  </li>
  <li>
    <p>T<em>{x</em>{t}}からランダムにサンプリングして、x_{t+1}とする</p>
  </li>
</ul>

<p>を繰り返すことによってサンプリングできる。
（xは離散値を取るとする）</p>

<p>πT = πを満たすための十分条件として、詳細釣り合い条件π(x) T<em>{xy} = π(y)T</em>{yx}がある。
これは十分条件でしかないが、この論文の主張によると、詳細釣り合い条件を満たしていないような遷移確率はこの論文での方法が初めてであるとのこと。</p>

<p>この論文では、メトロポリスヘイスティングやギブスサンプリングで発生する棄却確率を低減でき、また多くの場合棄却確率を0にできることを主張している。</p>

<p>MCMCでサンプリングを行う場合π<em>{x}そのものは計算出来ないと仮定することが多いので、それに比例するw</em>{x}を考える。πT = πはwT = wと同値。
v<em>{xy} = w</em>{x} T<em>{xy}とすると、この条件は、w</em>{x} = Σ<em>{y} v</em>{xy}とかける。さらに、棄却確率は Σ<em>{x} v</em>{xx}/Σ<em>{x} w</em>{x}とかける。</p>

<p>そこで、この論文では、w<em>{x}達をgivenとして、w</em>{x} = Σ<em>{y} v</em>{xy}, w<em>{x} = Σ</em>{y} v<em>{yx} を満たし、棄却確率を最小化するようなv</em>{xy}達を求めるアルゴリズムを提案している。
この問題はallocation problemと呼ばれている。</p>

<p>確かに、アルゴリズムはシンプルであるのだが、疑問なのがつぎの点である。実際にサンプリングをする時には、v<em>{xy}ではなく、(T</em>{xy})<em>{y} where T</em>{xy} = v<em>{xy}/w</em>{x} の分布に従ってサンプリングを行うが、
これは本当に実行できるのかという点である。もともとMCMCはw<em>{x}の分配関数を計算出来ない（intractable）であることからこのような遷移確率を用いたサンプリングを行っているので、Σ</em>{x}は実行できないはずである。
例えばxは2値を取る1000個のelementの全状態みたいなものを考えると、xの取りうる値は2^{1000}である。</p>

<p>そうすると、そもそもこのT_{xy}達をメモリで持てるという仮定や、その上で確率分布を取るといったことが可能かどうかは怪しいのではと思う。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Large_deviation_intro]]></title>
    <link href="http://delta2323.github.io/blog/2014/09/23/large-deviation-intro/"/>
    <updated>2014-09-23T14:22:05+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/09/23/large-deviation-intro</id>
    <content type="html"><![CDATA[<p>読んだ
http://people.math.umass.edu/~rsellis/pdf-files/boltzmann.pdf</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Birkhoff_von_neumann]]></title>
    <link href="http://delta2323.github.io/blog/2014/09/15/birkhoff-von-neumann/"/>
    <updated>2014-09-15T23:36:35+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/09/15/birkhoff-von-neumann</id>
    <content type="html"><![CDATA[<p>前に書いたHoffman–Wielandtの定理に関連してもう一つ。</p>

<p>Hoffman-Wielangtの定理は、Todd Kemp氏のレクチャーノートのLemma 5.4として証明されている。
Birkhoff-von Neumannの定理を用いると、その証明が比較的平易に行える事がわかった。</p>

<p>まず、Birkhoff-von Neumannの定理のステートメントを述べる為にいくつか言葉の定義を行う。</p>

<p>$d$次元の正方行列が、2重確率行列 (doubly stochastic matrix)であるとは、各行、各列の和が全て1である事を言う。
2つの2重確率行列の重み付き平均は再び2重確率行列となるので、2重確率行列全体の集合全体は凸であり、さらに多面体である事が知られている。これをBirkohff polytopeという。</p>

<p>特別な2重確率行列として、permutation matrixがある。これは、各行・各列に1つだけ1、残りが0である製法行列をいう。ベクトルにpermutation matrixをかけるとベクトルのエントリをシャッフル効果があるのでこう呼ばれる。</p>

<p>以上の準備のもとで、Birkhoff polytopeはpermutation matrix全体の集合の凸包であるというのが、Birkhoff-von Neumann定理である。</p>

<p>このことの帰結、Birkhoff polytope上に値を取る線形関数はpermutation matrix乗で最大・最小値を取る事がわかる。
前述のKemp氏のレクチャーノートでは、2つの対称行列の固有値を小さい順に並べた時の差の2乗の和をBirkhoff polytope上の線形関数で上から抑えた上でBirkhoff-von Neumannの定理を適用、考える対象をpermutation matrixに絞った上で、更に固有値を小さい順に並べていることから、permutationの中でも、単位行列で最大値を取ることを示し、それを式変形すると、その値は差の2乗のTraceであることを示している。</p>

<p>http://www.math.ucsd.edu/~tkemp/247A/247A.Notes.pdf</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inverse Tangentの加法定理]]></title>
    <link href="http://delta2323.github.io/blog/2014/09/15/inverse-tangent-addition-formula/"/>
    <updated>2014-09-15T21:43:00+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/09/15/inverse-tangent-addition-formula</id>
    <content type="html"><![CDATA[<script type="math/tex; mode=display">
\tan^{-1}(x) - \tan^{-1}(y) = \tan^{-1}\left(\frac{x-y}{1+xy}\right)
</script>

<p>ランダム行列のチュートリアルに出てきて「おー」と思ったけれど、冷静に見たら$\tan$の加法定理だった。</p>

<h2 id="section">出典</h2>

<p>下記参考文献の11ページ、3.1章</p>

<h2 id="section-1">参考文献</h2>

<ul>
  <li><a href="http://www-personal.umich.edu/~yudovina/lecture_notes/random_matrices.pdf">RANDOM MATRIX THEORY</a> S. Kargin and E. Yudovina</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gaussian Wigner Matrixの最大固有値の収束]]></title>
    <link href="http://delta2323.github.io/blog/2014/09/15/gaussian-wigner-matrices/"/>
    <updated>2014-09-15T21:22:00+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/09/15/gaussian-wigner-matrices</id>
    <content type="html"><![CDATA[<p>NIPS2012のランダム行列のチュートリアルからの抜粋。</p>

<p>$\mathbf{W}_{d}$を$d$次元対称行列で対角要素は$0$、非対角要素は標準正規分布に従う独立な確率変数とする。
すなわち、</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align*}
  \mathbf{W}_{d} = \sum_{i < j} X_{ij} \left(\mathbf{E}_{ij} + \mathbf{E}_{ji}\right)\quad
  (X_{ij})_{i < j} \sim \mathcal{N}(\mathbf{0}, \mathbf{I}_{d(d-1)/2}) 
\end{align*}
 %]]&gt;</script>

<p>$\lambda_{d}$を$\mathbf{W}_{d}$の最大固有値とすると、$\lambda_{d}/\sqrt{d}$は$d\to \infty$でalmost surelyに2に収束する。</p>

<p>参考にしているチュートリアルでの比較的簡単な証明で得られる結果（参考資料の定理4.1.1）では、
ここまでtightなバウンドを示すことができない（$\log d$のfactorがかかる）。
これ自体の証明は結構大変らしいが、できれば何か直感的な理解ができるような説明があるとうれしい。</p>

<p>また、ここで$\mathbf{W}_{d}$の事をWigner行列と呼んでいるが、Wigner行列自体はもっと広いクラスの行列を指す言葉の様子。
統計物理の文脈でよく出るようで、関連するチュートリアルや講義資料が多く見つかった。</p>

<p>（追記）</p>

<p>しばらく前にここまで原稿を書いた後によくよく考えたら、これはWigner’s Semicircle Lawからすぐに示せることに気づいた。
実際、以下のTodd Kemp氏のレクチャーノートで、Lemma 6.1としてこの事実をSemicircle Lawから示している。
NIPS2012のチュートリアルにあった「難しい定理」というのはSemicircle Lawの事だったのかな。</p>

<p>ついでに上に挙げたWigner行列のもっと広義の定義というのは、Kemp氏のチュートリアルによると、各エントリが独立かつ2乗の期待値が有限。さらに対角成分はi.i.d.の分布、非対角成分も（対角成分とは異なるかもしれない）i.i.d.の分布というものを言う（従って、スカラーの確率変数としては対角成分と非対角成分の2種類しかなく、2乗の期待値もその2種類での有限性だけ言えば十分）。
また、Wigner行列を$d^{-1/2}$（$d$は行列のサイズ）でスケール変換したものもWigner行列と言うらしい。</p>

<h2 id="section">出典</h2>

<p>Tropp氏のチュートリアルの35ページ、4.4.1章</p>

<h2 id="section-1">参考文献</h2>

<ul>
  <li><a href="http://users.cms.caltech.edu/~jtropp/notes/Tro12-User-Friendly-Tools-NIPS.pdf">User-Friendly Tools for Random Matrices: An Introduction</a></li>
</ul>

<p>Joel A. Tropp氏のNIPS2012のチュートリアル</p>

<ul>
  <li><a href="http://www.umpa.ens-lyon.fr/%7Eaguionne/pcmipark.pdf">Statistical Mechanics and Random Matrices</a></li>
</ul>

<p>Alice Guionnet氏のレクチャーノート</p>

<ul>
  <li><a href="http://www.math.ucsd.edu/~tkemp/247A/247A.Notes.pdf">MATH 247A: INTRODUCTION TO RANDOM MATRIX THEORY</a></li>
</ul>

<p>Todd Kemp氏のレクチャーノート</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stability_of_markov_chain]]></title>
    <link href="http://delta2323.github.io/blog/2014/09/14/stability-of-markov-chain/"/>
    <updated>2014-09-14T07:25:22+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/09/14/stability-of-markov-chain</id>
    <content type="html"><![CDATA[<p>これのTheorem3
http://arxiv.org/pdf/1306.1091.pdf</p>

<p>Reference元はこれらしい
http://www.sciencedirect.com/science/article/pii/S0024379501003202</p>

<p>更に言うとこれらしい
http://www.jstor.org/discover/10.2307/3212261?uid=3738328&amp;uid=2129&amp;uid=2&amp;uid=70&amp;uid=4&amp;sid=21104159480671</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hausdorff_measure]]></title>
    <link href="http://delta2323.github.io/blog/2014/09/06/hausdorff-measure/"/>
    <updated>2014-09-06T22:17:27+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/09/06/hausdorff-measure</id>
    <content type="html"><![CDATA[<p>http://en.wikipedia.org/wiki/Hausdorff_measure</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Coarea_formula]]></title>
    <link href="http://delta2323.github.io/blog/2014/09/06/coarea-formula/"/>
    <updated>2014-09-06T22:02:33+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/09/06/coarea-formula</id>
    <content type="html"><![CDATA[<p>geometric measure theoryという分野の有名な定理の一つ</p>

<p>wikipediaにも乗っているほど有名な定理らしい</p>

<p>Fubiniの定理のgeneralizationと思える</p>

<p>参考にした論文では、これを用いてthreshold setの表面積の期待値を上から評価している。
そして、期待値が小さいことから、適当なパラメータsが存在して、threshold setの表面積が実際に低くなることを証明している</p>

<p>http://en.wikipedia.org/wiki/Coarea_formula</p>

<p>http://arxiv.org/pdf/1309.1387v2.pdf</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shannon_source_coding_theorem]]></title>
    <link href="http://delta2323.github.io/blog/2014/09/03/shannon-source-coding-theorem/"/>
    <updated>2014-09-03T17:24:13+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/09/03/shannon-source-coding-theorem</id>
    <content type="html"><![CDATA[<p>Deep AutoRegressive Networkの3章に言及あり</p>

<p>Mackay 2003(Information theory inference and learning algorithms ch. 6)
Information Theory, Inference, and Learning Algorithms
http://www.inference.phy.cam.ac.uk/mackay/itila/book.html
結構有名な本らしい</p>

<p>http://www.iip.ist.i.kyoto-u.ac.jp/member/cuturi/Teaching/KU/2011/IIS/lec4-IT-2011.pdf
http://www.cs.cmu.edu/~aarti/Class/10704/lec8-srccodingHuffman.pdf</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gaussian_gradient]]></title>
    <link href="http://delta2323.github.io/blog/2014/09/03/gaussian-gradient/"/>
    <updated>2014-09-03T01:38:22+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/09/03/gaussian-gradient</id>
    <content type="html"><![CDATA[<p>http://arxiv.org/pdf/1401.4082v3.pdf
これの7, 8について書く</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Matrix キュムラント母関数の劣加法性]]></title>
    <link href="http://delta2323.github.io/blog/2014/08/26/subadditibity-of-matrix-cgf/"/>
    <updated>2014-08-26T22:00:00+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/08/26/subadditibity-of-matrix-cgf</id>
    <content type="html"><![CDATA[<p>通常の確率変数と同様に行列に値を取る確率変数に対しても積率母関数とキュムラント母関数を定義できる。
具体的には$d$次正方行列に値を取る確率変数$\mathbf{X}$に対して、その積率母関数(Moment Generating Function:MGF)$ M_{\mathbf{X}}$とキュムラント母関数(Cummurant Generating Function:CGF) $\Xi_{\mathbf{X}}$をスカラー値の場合と同様の形式に以下で定義する。すなわち、</p>

<script type="math/tex; mode=display">
\begin{align*}
  M_{\mathbf{X}}(\theta) = \mathbb{E}\left[ \exp (\theta \mathbf{X})\right]\\
  \Xi_{\mathbf{X}}(\theta) = \log \mathbb{E}\left[ \exp (\theta \mathbf{X})\right]
\end{align*}
</script>

<p>ここで$\theta \in \mathbb{R}$。</p>

<p>すると、CGFに関して次が成立する。$\mathbf{X}_{i}(i = 1, \ldots, n)$を$d$次正方行列に値を取る独立な確率変数として、次の不等式が成立する。</p>

<script type="math/tex; mode=display">
\begin{align*}
  \mathrm{tr} \exp \left(\Xi_{\left(\sum_{i} \mathbf{X}_{i}\right)}(\theta)\right) \leq \mathrm{tr} \exp \left( \sum_{i} \Xi_{\mathbf{X}_{i}} (\theta)\right).
\end{align*}
</script>

<p>スカラー値の確率変数の場合、MGFには乗法性、CGFには加法性が成立する。MGFの乗法性は次のように示せる。</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align*}
M_{\sum_{i}X_{i}}(\theta) &= \mathbb{E}\left[ \exp(\theta \sum_{i}X_{i})\right] \\
                          &= \mathbb{E}\left[ \prod_{i} \exp(\theta X_{i}) \right] \\
                          &= \prod_{i} \mathbb{E}\left[ \exp(\theta X_{i}) \right] \\
						  &= \prod_{i} M_{X_{i}} (\theta)
\end{align*}
 %]]&gt;</script>

<p>ここで、3行目の等式では、$X_{i}$達の独立性を用いた。この式の$\log$を取れば、CGFの加法性も言える。</p>

<p>しかし、行列値の場合はこのような式変形はできない。
スカラー値$x, y$に対しては、$\exp(x+y) = \exp(x)\exp(y)$が成立する。
一方、行列$\mathrm{X}, \mathrm{Y}$に対しては、一般的には$\exp(\mathrm{X}+\mathrm{Y}) = \exp(\mathrm{X})\exp(\mathrm{Y})$が成立せず、従って、2行目の等式が成立しないためである
（例えば$\mathrm{X}, \mathrm{Y}$が可換である事は$\exp$の分配法則が成立する十分条件である）。</p>

<p>冒頭に上げた定理は、それにもかかわらず$\mathrm{tr} \exp$を取ればCGFに関しては劣加法性だけは成立している事を主張している。</p>

<h2 id="section">出典</h2>

<p>下記のチュートリアルの25ページ、Lemma 3.5.1</p>

<h2 id="section-1">参考文献</h2>

<ul>
  <li><a href="http://users.cms.caltech.edu/~jtropp/notes/Tro12-User-Friendly-Tools-NIPS.pdf">User-Friendly Tools for Random Matrices: An Introduction</a></li>
</ul>

<p>Joel A. Tropp氏のNIPS2012のチュートリアル</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chernoff Inequality]]></title>
    <link href="http://delta2323.github.io/blog/2014/08/25/chernoff-inequality/"/>
    <updated>2014-08-25T21:17:15+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/08/25/chernoff-inequality</id>
    <content type="html"><![CDATA[<p>$X_{1}, \ldots, X_{n}$を独立な確率変数（同分布である必要はない）で、ある$K&gt;0$が存在して、任意の$i$についてalmost surelyに$|X_{i}| &lt; K$が成立するとする。
確率変数$X_{i}$の期待値を$\mu_{i}$、分散を$\sigma_{i}^{2}$とし、$\mu = \sum_{i=1}^{n} \mu_{i}$、$\sigma^{2} = \sum_{i=1}^{n} \sigma_{i}^{2}$、
$S=\sum_{i=1}^{n}X_{i}$と置く。</p>

<p>この時、定数$C, c$が存在して、任意の$\lambda &gt; 0$に対し、</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align*}
  \mathbb{P}(|S - \mu| > \lambda \sigma) <  C\max (\exp(-c\lambda^{2}), \exp(-c\lambda\sigma /K))
\end{align*}
 %]]&gt;</script>

<p>証明は、まず、Hoeffding’s lammaと呼ばれる補題から、$X$の積率母関数に関する評価、</p>

<script type="math/tex; mode=display">
\begin{align*}
  \mathbb{E} \exp(tX) \leq \exp(O(t^{2} \sigma_{i}^{2}))
\end{align*}
</script>

<p>を得る。ここから、$X_{i}$達の独立性より$\mathbb{E}\exp(tS)$を$X_{i}$の積率母関数の積で書けるので、それぞれの項を上の不等式で評価する。
最後にMarkovの補題を用いて、定理の左辺を上から評価し、最後に$t$について最小値をとる事で求める不等式が得られる。</p>

<h2 id="section">出典</h2>

<p>下記参考文献の75ページ</p>

<h2 id="section-1">参考文献</h2>

<ul>
  <li><a href="http://terrytao.files.wordpress.com/2011/02/matrix-book.pdf">Topics in random matrix theory</a></li>
</ul>

<p>ランダム行列に関するTerence Tao氏講義ノート</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markov's Inequality]]></title>
    <link href="http://delta2323.github.io/blog/2014/08/25/markov-inequality/"/>
    <updated>2014-08-25T20:58:00+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/08/25/markov-inequality</id>
    <content type="html"><![CDATA[<p>非負の確率変数が外れ値を取る確率は期待値で抑えられるという定理。
Concentration Inequalityと呼ばれる一連の不等式達の中でおそらくいちばん基本的な不等式。
Wikipediaにあるように証明は数行で終わるのだけれど、応用範囲がものすごく広くここからこの系統の種々の不等式を導ける。</p>

<p>$X$を$\mathbb{R}$に値を取る非負の確率変数。$t&gt;0$に対して以下が成立する。</p>

<script type="math/tex; mode=display">
\begin{align*}
  \mathbb{P}\left[ X \geq t\right] \leq \frac{\mathbb{E}[X]}{t}
\end{align*}
</script>

<p>$X$が非負の条件を外すと簡単に反例を作れる（例えば$X$が常に負を取るような確率変数など）。</p>

<h2 id="section">出典</h2>

<p>色々。例えばWikpediaの<a href="http://en.wikipedia.org/wiki/Concentration_inequality">Concentration Inequalities</a>の項目。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Azuma' Lemma]]></title>
    <link href="http://delta2323.github.io/blog/2014/08/24/azuma-lemma/"/>
    <updated>2014-08-24T14:41:27+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/08/24/azuma-lemma</id>
    <content type="html"><![CDATA[<p>Chernoffの不等式では、$X_{i}$達の独立性を仮定していた。
しかし、実はもっと緩い仮定でもChernoffの不等式に近い不等式を示すことができる。
それがAzumaの不等式。</p>

<p>Wikipediaを信じるならば、名前は、発見者の吾妻一興氏に由来し、この論文で発表されたのが初出らしい。</p>

<p>http://projecteuclid.org/DPubS?verb=Display&amp;version=1.0&amp;service=UI&amp;handle=euclid.tmj/1178243286&amp;page=record</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Airy 関数]]></title>
    <link href="http://delta2323.github.io/blog/2014/08/24/airy-function/"/>
    <updated>2014-08-24T11:17:32+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/08/24/airy-function</id>
    <content type="html"><![CDATA[<p>次の2階の線型微分方程式を考える。</p>

<script type="math/tex; mode=display">
\begin{align*}
  \frac{\mathrm{d}^{2}y}{\mathrm{d}x^{2}} - xy = 0
\end{align*}
</script>

<p>これの線型独立な解として、次の2つがとれる。</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align*}
  \mathrm{Ai}(x) &= \frac{1}{\pi} \int_{0}^{\infty} \cos\left(\frac{t^{3}}{3}+xt \right) \mathrm{d}t \\
  \mathrm{Bi}(x) &= \frac{1}{\pi} \int_{0}^{\infty} \exp\left(-\frac{t^{3}}{3}+xt\right) + \sin \left(\frac{t^{3}}{3}+xt\right) \mathrm{d}t
\end{align*}
 %]]&gt;</script>

<p>両者が収束することは、部分積分するとわかる。
もしくは、alternating testからわかる。</p>

<p>もしくは、ここにあるものを使えば、$x=0$の場合については、直接示せている。
http://en.wikipedia.org/wiki/Fresnel_integral</p>

<p>http://n.ethz.ch/~lukaswi/download/WS0506/MMP1/solution9-2.pdf
https://www.math.ucdavis.edu/~tracy/talks/SITE7.pdf</p>

<p>Riemann-Lesbegueの定理から言えるかと悩んだけれどうまく言えなかった。
$\mathrm{Ai}$の方をAiry関数と呼ぶ。</p>

<p>ランダム行列について調べていて、このAiry関数に行き当たったが、Airy関数とランダム行列の関係は例えば、ここに書いてある</p>

<p>https://www.math.ucdavis.edu/~tracy/talks/SITE7.pdf</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hoffman Wielandtの定理]]></title>
    <link href="http://delta2323.github.io/blog/2014/08/17/hoffman-wielandt/"/>
    <updated>2014-08-17T15:52:15+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/08/17/hoffman-wielandt</id>
    <content type="html"><![CDATA[<p>$A$, $B$を$d$次元の対称行列とし、それぞれの固有値を$\lambda_{1} \leq \cdots \leq \lambda_{d}$, $\mu_{1} \leq \cdots \leq \mu_{d}$とする。
この時次が成立する：</p>

<script type="math/tex; mode=display">
\sum_{i=1}^{d} (\lambda_{i} - \mu_{i})^{2} \leq \mathrm{tr} (A-B)^{2} \leq 2\sum_{i \leq j} (A_{ij} - B_{ij})^{2}.
</script>

<p>この形での不等式は下記の参考文献の形でのステートメントだが、調べてみると、$A, B$の条件は正規行列までゆるめて、最右辺をフロベニウスノルム$|A-B|_{F}^{2} = \sum_{i, j} \left(A_{ij} - B_{ij}\right)^{2}$で抑えれられていることが多い様子
（実正方行列$A$が正規であるとは$A^{t}A = AA^{t}$が成立すること）。
対称行列は正規なので、特別な場合とみなせるが、今回のステートメントのほうが最右辺の値は$\sum_{i=1}^{d} (A_{ii}-B_{ii})^{2}$だけ大きい。</p>

<p>また、真ん中の項は入っていない形をHoffman Wielandtの定理としているケースが多い様子
（真ん中の項は2乗とtraceを適用する順番がわからない..）。</p>

<p>対称行列$X$の固有値を$\lambda_{1}, \ldots, \lambda{d}$とした時、$X$のStieltjes変換$g_{X}$とは、$g_{X}(z) = \frac{1}{d} \sum_{i=1}^{d} \frac{1}{\lambda_{i} - z}$の事を言う。
これを用いると、Stieltjes変換の（$z$についてではなく、$X$についての）Lipschitz連続性が言える（らしい）。</p>

<h2 id="section">出典</h2>

<p>RANDOM MATRIX THEORYの15ページLemma 3.9</p>

<h2 id="section-1">参考文献</h2>

<ul>
  <li><a href="http://www-personal.umich.edu/~yudovina/lecture_notes/random_matrices.pdf">RANDOM MATRIX THEORY</a> S. Kargin and E. Yudovina</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[測度のVague収束]]></title>
    <link href="http://delta2323.github.io/blog/2014/08/17/vague-convergence/"/>
    <updated>2014-08-17T14:19:17+09:00</updated>
    <id>http://delta2323.github.io/blog/2014/08/17/vague-convergence</id>
    <content type="html"><![CDATA[<p>測度の収束の種類としてVague Convergenceというものがあることを知る。</p>

<p>定義自体は弱収束とよく似ている。
$\mathbb{R}$上の測度の列$(\mu_{n})_{n=0, \ldots}$が$\mu$にVague収束するとは、任意の$f\in \mathcal{C}_{\infty}(\mathbb{R})$に対して、
$\int_{\mathbb{R}} f(x) \mathrm{d}{\mu_{n}}(x)$が$\int_{\mathbb{R}} f(x) \mathrm{d}{\mu}(x)$に収束することをいう。
ここで、$\mathcal{C}_{\infty}(\mathbb{R})$は、$\mathbb{R}$上の連続関数$f$で、$f(x) \to 0$ (as $x \to \pm \infty$)となるものを言う
（下記の参考文献では$\mathcal{C}_{0}(\mathbb{R})$と書いているけれど、自分はこの記号はコンパクト台に使うことが多い気がしたので表記を変えてみた）。</p>

<p>上記の定義は$\mathbb{R}$上であったが、Vague収束の概念はより一般的にLocally Compact Hausdorffな位相空間でも良いらしい。</p>

<p>上の定義で、$\mathcal{C}_{\infty}(\mathbb{R})$を連続関数全体の集合$\mathcal{C}^{0}(\mathbb{R})$に変更すると弱収束の定義になる。
$\mathcal{C}_{\infty}(\mathbb{R}) \subset \mathcal{C}^{0}(\mathbb{R})$なので、弱収束すればVague収束するが、その逆は成立しない。
例えば参考文献の例を挙げると、$\mu$を台がコンパクトで全空間での積分が有限な測度として、$\mu_{n}(x) = \mu(x-n)$と定義すると、$(\mu_{n})_{n=0, \ldots}$は0にVague収束するが弱収束はしない。
従って、Vague収束は弱収束より真に弱い条件となっている。</p>

<p>しかし、測度が確率測度であるときはVague収束の収束先に追加で条件をつければ弱収束が言える。
具体的には参考文献のFact2にある通り、確率測度列がVague収束し、さらに収束先も確率測度である時、この収束列はVague収束先に弱収束している。</p>

<h2 id="section">出典</h2>

<p>RANDOM MATRIX THEORYの12ページ3.1章</p>

<h2 id="section-1">参考文献</h2>

<ul>
  <li>
    <p><a href="http://www-personal.umich.edu/~yudovina/lecture_notes/random_matrices.pdf">RANDOM MATRIX THEORY</a> S. Kargin and E. Yudovina</p>
  </li>
  <li>
    <p>Wikipediaの<a href="http://en.wikipedia.org/wiki/Vanish_at_infinity">Vague topology</a>の項目</p>
  </li>
</ul>
]]></content>
  </entry>
  
</feed>
